# Factory Pattern

The Factory Pattern is a creational design pattern.

`Defines an interface for creating an object, but let the subclasses decide which
class to instantiate. The Factory Pattern lets a class defer the instantiation it 
uses to subclasses.`

### Problems it solves:
**Tight Coupling**: Without the factory pattern, code might be tightly coupled to specific classes, making it harder to adapt or extend in the future.

**Complex Object Creation**: If object creation involves complex logic, it's better to manage it centrally rather than in multiple places across the code.

**Scalability**: It helps in scaling applications by allowing developers to introduce new product types without altering existing code drastically.

### Code

```csharp
using System;

//CreditCard.cs
namespace FactoryDesignPattern
{
    public interface CreditCard
    {
        string GetCardType();
        int GetCreditLimit();
        int GetAnnualCharge();
    }
}

//MoneyBack.cs
namespace FactoryDesignPattern
{
    class MoneyBack : CreditCard
    {
        public string GetCardType()
        {
            return "MoneyBack";
        }

        public int GetCreditLimit()
        {
            return 15000;
        }

        public int GetAnnualCharge()
        {
            return 500;
        }
    }
}

//Titanium.cs
namespace FactoryDesignPattern
{
    public class Titanium : CreditCard
    {
        public string GetCardType()
        {
            return "Titanium Edge";
        }
        public int GetCreditLimit()
        {
            return 25000;
        }
        public int GetAnnualCharge()
        {
            return 1500;
        }
    }
}

//Platinum.cs
namespace FactoryDesignPattern
{
    public class Platinum : CreditCard
    {
        public string GetCardType()
        {
            return "Platinum Plus";
        }
        public int GetCreditLimit()
        {
            return 35000;
        }
        public int GetAnnualCharge()
        {
            return 2000;
        }
    }
}

//Client Code (Main Method)
using System;
namespace FactoryDesignPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            //Generally we will get the Card Type from UI.
            //Here we are hardcoded the card type
            string cardType = "MoneyBack";

            CreditCard cardDetails = null;

            //Based of the CreditCard Type we are creating the
            //appropriate type instance using if else condition
            if (cardType == "MoneyBack")
            {
                cardDetails = new MoneyBack();
            }
            else if (cardType == "Titanium")
            {
                cardDetails = new Titanium();
            }
            else if (cardType == "Platinum")
            {
                cardDetails = new Platinum();
            }

            if (cardDetails != null)
            {
                Console.WriteLine("CardType : " + cardDetails.GetCardType());
                Console.WriteLine("CreditLimit : " + cardDetails.GetCreditLimit());
                Console.WriteLine("AnnualCharge :" + cardDetails.GetAnnualCharge());
            }
            else
            {
                Console.Write("Invalid Card Type");
            }

            Console.ReadLine();
        }
    }
}

```


**What is the Problem with the above Code Implementation?**:
The above code implementation introduces the following problems

* First, the Tight Coupling between the client class (Program) and Product Classes (MoneyBack, Titanium, and Platinum). So, when we make changes in one class, we must also make changes in the other classes.
* Secondly, suppose we add a new Credit Card. In that case, we also need to modify the client code, i.e., the main method of the Program class, by adding an extra IF-ELSE Condition, which not only overheads the development but also the testing process.

**Fix**

```csharp
//CreditCardfactory.cs
namespace FactoryDesignPattern
{
    public class CreditCardFactory
    {
        public static CreditCard GetCreditCard(string cardType)
        {
            CreditCard cardDetails = null;

            if (cardType == "MoneyBack")
            {
                cardDetails = new MoneyBack();
            }
            else if (cardType == "Titanium")
            {
                cardDetails = new Titanium();
            }
            else if (cardType == "Platinum")
            {
                cardDetails = new Platinum();
            }

            return cardDetails;
        }
    }
}

//Client Code (Main.cs)
using System;
namespace FactoryDesignPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            CreditCard cardDetails = CreditCardFactory.GetCreditCard("Platinum");
            
            if (cardDetails != null)
            {
                Console.WriteLine("CardType : " + cardDetails.GetCardType());
                Console.WriteLine("CreditLimit : " + cardDetails.GetCreditLimit());
                Console.WriteLine("AnnualCharge :" + cardDetails.GetAnnualCharge());
            }
            else
            {
                Console.Write("Invalid Card Type");
            }

            Console.ReadLine();
        }
    }
}

```
The client code remains unchanged, adhering to the **Open-Closed Principle**. ðŸš€

### Class Diagram ###

![Image Description](.\Images\Factory-Design-Pattern-UML-Diagram-1024x553.jpeg)


### Production Code ###

Factory

```csharp

namespace CSharpUtils.Storage
{
    public interface IStorageFactory
    {
        //IStoage is an interface for different storages
        //Concrete implementations - S3Storage, FSStorage
        IStorage GetOrCreateStorage(string url);
    }
}


namespace CSharpUtils.Storage
{
    public class StorageFactory : IStorageFactory
    {
        private readonly IConfiguration _configuration;
        private readonly ILoggerFactory _loggerFactory;
        private readonly ConcurrentDictionary<string, IStorage> _storageDictionary = new ConcurrentDictionary<string, IStorage>();

        public StorageFactory(IConfiguration configuration, ILoggerFactory loggerFactory)
        {
            _configuration = configuration;
            _loggerFactory = loggerFactory;
        }

        public IStorage GetOrCreateStorage(string url)
        {
            return _storageDictionary.GetOrAdd(url, CreateStorage);
        }

        private IStorage CreateStorage(string url)
        {
            try
            {
                IStorage storage = Create(url);
                _storageDictionary.TryAdd(url, storage);
                return storage;
            }
            catch (Exception ex)
            {
                var logger = _loggerFactory.CreateLogger<StorageFactory>();
                logger.LogError(ex, "Failed to create storage for URL: {Url}", url);
                throw new Exception(ex.Message);
            }
        }

        private IStorage Create(string url)
        {
            if (url.StartsWith("s3://", StringComparison.OrdinalIgnoreCase))
            {
                return CreateS3Storage(url);
            }
            else if (url.StartsWith("file://", StringComparison.OrdinalIgnoreCase) || url.StartsWith("C://", StringComparison.OrdinalIgnoreCase))
            {
                return CreateFSStorage(url);
            }
        }

        private IStorage CreateS3Storage(string url)
        {
            try
            {
                var s3StorageSetup = new S3StorageSetup();
                GetS3BucketNameAndBasePathFromURL(url, out string bucketName, out string basePath);
                s3StorageSetup.BucketName = bucketName;
                s3StorageSetup.BasePath = basePath;

                var options = _configuration.GetAWSOptions();
                var s3AmazonClient = options.CreateServiceClient<IAmazonS3>() as AmazonS3Client;

                return new S3Storage(Options.Create(s3StorageSetup), s3AmazonClient, new Logger<S3Storage>(_loggerFactory));
            }
            catch (Exception ex)
            {
                var logger = _loggerFactory.CreateLogger<StorageFactory>();
                logger.LogError(ex, "Failed to create S3 storage for URL: {Url}", url);
                throw;
            }
        }

        private IStorage CreateFSStorage(string url)
        {
            try
            {
                var rootLocation = GetFSRootLocationFromURL(url);
                var fsStorageSetup = new FSStorageSetup { RootLocation = rootLocation };
                return new FSStorage(Options.Create(fsStorageSetup), new Logger<FSStorage>(_loggerFactory));
            }
            catch (Exception ex)
            {
                var logger = _loggerFactory.CreateLogger<StorageFactory>();
                logger.LogError(ex, "Failed to create File System storage for URL: {Url}", url);
                throw;
            }
        }

        private void GetS3BucketNameAndBasePathFromURL(string url, out string bucketName, out string basePath)
        {
            bucketName = "";
            basePath = "";
            string remainingUrl = url.Substring(5); // remove "s3://"
            int firstDoubleSlash = remainingUrl.IndexOf("//", StringComparison.Ordinal);

            if (firstDoubleSlash != -1)
            {
                bucketName = remainingUrl.Substring(0, firstDoubleSlash);
                if (firstDoubleSlash + 2 < remainingUrl.Length)
                {
                    basePath = remainingUrl.Substring(firstDoubleSlash + 2);
                }
            }
            else
            {
                bucketName = remainingUrl;
            }
        }

        private string GetFSRootLocationFromURL(string url)
        {
            if (url.StartsWith("file://", StringComparison.OrdinalIgnoreCase))
            {
                return url.Substring(7); // Remove "file://"
            }
            else
            {
                // Check if it looks like a drive root (e.g., "C://")
                if (url.Length >= 2 && char.IsLetter(url[0]) && url[1] == ':')
                {
                    // Return only the drive root (e.g., "C://")
                    return url.Substring(0, 2) + "//"; // Add trailing backslash for consistency
                }
                else
                {
                    // If it's not a "file://" URL or a drive root, handle as appropriate.
                    _loggerFactory.CreateLogger<StorageFactory>().LogError($"Invalid file system URL: {url}");
                    throw new ArgumentException($"Invalid file system URL: {url}");
                }
            }
        }
    }
}

```

Client Code

```csharp

Consistency.cs

namespace Consistency
{
    public class Consistency
    {
        private IStorageFactory _storageFactory;
        private string _from;
        private string _to;

        public Consistency(IStorageFactory storageFactory)
        {
            storageFactory = _storageFactory;
        }

        public void Process()
        {
            FetchParameters();
            InstantiateStorage();
        }

        private InstantiateStorage()
        {
            try{
                _inputStorage  = _storageFactory.GetOrCreateStorage(_inputPath);
                _outputStorage = _storageFactory.GetOrCreateStorage(_outputPath);
            }
            catch(Exception){
                throw
            }
        }

    }
}

Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IStorageFactory, StorageFactory>();
}
    

Program.cs

namespace Program
{
    public class Program
    {
        private readonly IServiceProvider _serviceProvider;

        public Program(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public static void Main()
        {
            // Retrieve service instance from DI container
            var _storageFactory = _serviceProvider.GetService<IStorageFactory>();
            Consistency consistency = new Consistency(_storageFactory);
            consistency.Process();
        }
    }    
}

```