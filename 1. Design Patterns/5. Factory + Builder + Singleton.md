## Step-by-Step Code Implementation ##

### Define the Logger Interface ###
The interface will define common methods for logging.
```csharp
public interface ICustomLogger
{
    void LogInformation(string message);
    void LogWarning(string message);
    void LogError(string message);
}

```

### Concrete Logger Implementations ###
Create loggers for different targets (e.g., Console, File).

#### ConsoleLogger: ####
```csharp
public class ConsoleLogger : ICustomLogger
{
    public void LogInformation(string message)
    {
        Console.WriteLine($"[INFO]: {message}");
    }

    public void LogWarning(string message)
    {
        Console.WriteLine($"[WARNING]: {message}");
    }

    public void LogError(string message)
    {
        Console.WriteLine($"[ERROR]: {message}");
    }
}

```

#### FileLogger: ####

```csharp
using System.IO;

public class FileLogger : ICustomLogger
{
    private readonly string _filePath;

    public FileLogger(string filePath)
    {
        _filePath = filePath;
    }

    public void LogInformation(string message)
    {
        WriteToFile($"[INFO]: {message}");
    }

    public void LogWarning(string message)
    {
        WriteToFile($"[WARNING]: {message}");
    }

    public void LogError(string message)
    {
        WriteToFile($"[ERROR]: {message}");
    }

    private void WriteToFile(string message)
    {
        File.AppendAllText(_filePath, $"{DateTime.Now} {message}{Environment.NewLine}");
    }
}

```


#### Factory Class ####
The factory dynamically creates loggers based on configuration or input.

```csharp
public static class LoggerFactory
{
    public static ICustomLogger CreateLogger(string type, string filePath = null)
    {
        return type.ToLower() switch
        {
            "console" => new ConsoleLogger(),
            "file" => new FileLogger(filePath ?? "default.log"),
            _ => throw new ArgumentException("Invalid logger type")
        };
    }
}

```

#### Builder Class ####
The builder constructs the logger step by step based on configuration.

```csharp
public class LoggerBuilder
{
    private string _type;
    private string _filePath;

    public LoggerBuilder UseConsoleLogger()
    {
        _type = "console";
        return this;
    }

    public LoggerBuilder UseFileLogger(string filePath)
    {
        _type = "file";
        _filePath = filePath;
        return this;
    }

    public ICustomLogger Build()
    {
        return LoggerFactory.CreateLogger(_type, _filePath);
    }
}

```

#### Singleton Implementation ####

Ensure only one logger instance is created.

```csharp
public sealed class SingletonLogger
{
    private static ICustomLogger _instance;
    private static readonly object _lock = new object();

    private SingletonLogger() { }

    public static ICustomLogger GetInstance(LoggerBuilder builder)
    {
        if (_instance == null)
        {
            lock (_lock)
            {
                if (_instance == null)
                {
                    _instance = builder.Build();
                }
            }
        }
        return _instance;
    }
}

```

#### Client Code ####
Use the builder, factory, and singleton patterns in the client code.

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Configure logger using Builder Pattern
        var builder = new LoggerBuilder()
            .UseFileLogger("application.log"); // Change to .UseConsoleLogger() if needed
                                               // .build() is moved inside the SingletonLogger to make the object singleton.

        // Get Singleton Logger Instance
        var logger = SingletonLogger.GetInstance(builder);

        // Log Messages
        logger.LogInformation("Application started.");
        logger.LogWarning("Potential issue detected.");
        logger.LogError("An error occurred.");
    }
}

```

#### Explanation ####
* Singleton Pattern: Ensures that only one logger instance is created and shared across the application.

* Builder Pattern: Allows flexible configuration of the logger (e.g., choosing between ConsoleLogger and FileLogger).

* Factory Pattern: Dynamically creates appropriate logger types based on input or configuration.